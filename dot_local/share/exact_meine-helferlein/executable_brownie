#!/usr/bin/env bash
# brownie: launch aider in a container with a per-session persistent volume
#
# Why "Brownie"?
#   In Scottish/English folklore, a Brownie is a helpful house-spirit that
#   tidies and assists quietly at nightâ€”so long as it's respected. This script
#   aims to be that kind of helper for your Aider sessions: unobtrusive,
#   practical, and tidy about your files.
#
# Usage:
#   brownie [wrapper-opts] [aider-opts ...] -- [docker run opts ...]
#
# Behavior:
#   â€¢ Args BEFORE `--` go to Aider inside the container.
#   â€¢ Args AFTER  `--` go to `docker run`.
#   â€¢ Env/config are bind-mounted read-only to /config/<basename> in the container.
#   â€¢ If not provided in [aider-opts], defaults injected:
#       --env-file /config/<env basename>
#       --config   /config/<config basename>

set -Eeuo pipefail

DEFAULT_IMAGE="paulgauthier/aider-full:latest"
DEFAULT_PREFIX="brownie"

PULL_IMAGE=0
SESSION_NAME=""
IMAGE="$DEFAULT_IMAGE"
GIT_CONFIG_DIR_OVERRIDE=""
DOCKER_EXTRAS=()
AIDER_ARGS=()

BROWNIE_ABOUT=$'Brownie â€” a friendly nod to the Scottish/English household spirit.\n\
In folklore, a Brownie is a quiet helper who keeps things tidy if treated well.\n\
Likewise, this tool keeps Aider sessions neat by creating a persistent per-session\n\
volume under ~/.local/share/aider/sessions and mounting it at /aider.\n\
Be respectful; keep your config/env in orderâ€”and the work flows. ðŸ™‚'

die() { printf 'error: %s\n' "$*" >&2; exit 1; }

usage() {
  cat <<'USAGE'
Usage:
  brownie [wrapper-opts] [aider-opts ...] -- [docker run opts ...]

Wrapper options (before --):
  -n, --name         Docker-compatible session/container/volume name.
  -i, --image        Image to run (default: paulgauthier/aider-full:latest).
      --git-config   Path to Git config directory (default: XDG config path).
      --pull         Always docker pull IMAGE before running.
      --about        Explain why this tool is named "Brownie".
  -h, --help         Show this help and exit.

Mounting & defaults:
  â€¢ $AIDER_ENV_FILE   â†’ /config/<env basename>   (read-only)
  â€¢ $AIDER_CONFIG_CONTAINER â†’ /config/<config basename> (read-only)
  â€¢ Git config dir   â†’ /config/git              (read-only)
  â€¢ Injected into Aider iff you didn't provide them:
      --env-file /config/<env basename>
      --config   /config/<config basename>

Examples:
  brownie --model o4-mini -- --rm --network host
  brownie --message "Hello" -- --rm -e FOO=bar
  brownie -n docs -- --rm
USAGE
}

have() { command -v "$1" >/dev/null 2>&1; }
require_env() { local var="$1"; [ -n "${!var:-}" ] || die "$var is not set. Export it and retry."; }

get_git_config_dir() {
  local git_config_dir
  if [ -n "$GIT_CONFIG_DIR_OVERRIDE" ]; then
    git_config_dir="$GIT_CONFIG_DIR_OVERRIDE"
  elif [ -n "${XDG_CONFIG_HOME:-}" ]; then
    git_config_dir="$XDG_CONFIG_HOME/git"
  else
    git_config_dir="$HOME/.config/git"
  fi
  printf '%s\n' "$git_config_dir"
}
lower() { tr '[:upper:]' '[:lower:]'; }

sanitize_docker_name() {
  local in="${1:-}" out
  out="$(printf '%s' "$in" | lower | tr -c 'a-z0-9._-' '-')"
  out="$(printf '%s' "$out" | sed -E 's/^[^a-z0-9]+//')"
  out="$(printf '%s' "$out" | sed -E 's/[-._]+$//')"
  [ -n "$out" ] || out="session"
  out="${out:0:128}"
  printf '%s\n' "$out"
}

rand6() {
  LC_ALL=C tr -dc 'a-z0-9' </dev/urandom 2>/dev/null | head -c6 || \
  printf '%s' "$(date +%s%N | md5 2>/dev/null | cut -c1-6)"
}

ensure_unique_container_name() {
  local name="$1"
  if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
    die "Container name '$name' already exists. Choose a different --name."
  fi
}

list_existing_sessions() {
  docker ps -a --filter "name=${DEFAULT_PREFIX}-" --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}" 2>/dev/null || true
}

get_existing_session_names() {
  docker ps -a --filter "name=${DEFAULT_PREFIX}-" --format "{{.Names}}" 2>/dev/null | sort || true
}

prompt_session_choice() {
  local existing_sessions
  existing_sessions="$(get_existing_session_names)"
  
  if [ -z "$existing_sessions" ]; then
    # No existing sessions, proceed with new session creation
    SESSION_NAME="$(prompt_session_name)"
    return 0
  fi
  
  echo "Found existing sessions:"
  list_existing_sessions
  echo
  echo "Options:"
  echo "  1) Resume an existing session"
  echo "  2) Create a new session"
  echo
  
  local choice
  read -r -p "Choose option (1 or 2): " choice
  
  case "$choice" in
    1)
      echo "Available sessions:"
      local i=1
      local session_array=()
      while IFS= read -r session; do
        echo "  $i) $session"
        session_array+=("$session")
        ((i++))
      done <<< "$existing_sessions"
      
      if [ ${#session_array[@]} -eq 1 ]; then
        SESSION_NAME="${session_array[0]}"
        echo "Resuming session: $SESSION_NAME"
      else
        echo
        read -r -p "Enter session number to resume: " session_num
        if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -ge 1 ] && [ "$session_num" -le ${#session_array[@]} ]; then
          SESSION_NAME="${session_array[$((session_num-1))]}"
          echo "Resuming session: $SESSION_NAME"
        else
          die "Invalid session number"
        fi
      fi
      return 1  # Signal that we're resuming
      ;;
    2)
      SESSION_NAME="$(prompt_session_name)"
      return 0  # Signal that we're creating new
      ;;
    *)
      die "Invalid choice. Please enter 1 or 2."
      ;;
  esac
}

ensure_volume_bound() {
  local vol="$1" hostdir="$2"
  mkdir -p "$hostdir"
  if ! docker volume inspect "$vol" >/dev/null 2>&1; then
    docker volume create \
      --driver local \
      --opt type=none \
      --opt o=bind \
      --opt device="$hostdir" \
      "$vol" >/dev/null
  fi
}

prompt_session_name() {
  local base hash candidate
  read -r -p "Session name (leave blank to auto-generate): " candidate || true
  candidate="$(sanitize_docker_name "$candidate")"
  if [ -z "$candidate" ] || [ "$candidate" = "session" ]; then
    base="$(basename "$PWD" | sanitize_docker_name)"
    [ -n "$base" ] || base="workspace"
    hash="$(rand6)"
    candidate="$(sanitize_docker_name "${DEFAULT_PREFIX}-${base}-${hash}")"
  fi
  printf '%s\n' "$candidate"
}

print_about() { printf '%s\n' "$BROWNIE_ABOUT"; }

# ---------- parse args: wrapper opts anywhere before `--`; others -> Aider ----------
parse_args() {
  local after_delim=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --) after_delim=1; shift; break ;;
      -h|--help) usage; exit 0 ;;
      --about) print_about; exit 0 ;;
      -n|--name) [ $# -ge 2 ] || die "--name requires an argument"
                 SESSION_NAME="$(sanitize_docker_name "$2")"; shift 2 ;;
      -i|--image) [ $# -ge 2 ] || die "--image requires an argument"
                  IMAGE="$2"; shift 2 ;;
      --git-config) [ $# -ge 2 ] || die "--git-config requires an argument"
                    GIT_CONFIG_DIR_OVERRIDE="$2"; shift 2 ;;
      --pull) PULL_IMAGE=1; shift ;;
      *) AIDER_ARGS+=("$1"); shift ;;  # Aider arg
    esac
  done

  if [ "$after_delim" -eq 1 ]; then
    while [ $# -gt 0 ]; do DOCKER_EXTRAS+=("$1"); shift; done
  fi
}

parse_args "$@"

# ---------- preflight ----------
have docker || die "docker not found in PATH."
require_env "AIDER_CONFIG_CONTAINER"
require_env "AIDER_ENV_FILE"
[ -f "$AIDER_CONFIG_CONTAINER" ] || die "AIDER_CONFIG_CONTAINER points to a non-file: $AIDER_CONFIG_CONTAINER"
[ -f "$AIDER_ENV_FILE" ] || die "AIDER_ENV_FILE points to a non-file: $AIDER_ENV_FILE"

# Git config directory
GIT_CONFIG_DIR="$(get_git_config_dir)"
GIT_CONFIG_IN="/config/git"

# Derive container-side config paths under /config
CONF_DIR_IN="/config"
ENV_BASENAME="$(basename -- "$AIDER_ENV_FILE")"
CONF_BASENAME="$(basename -- "$AIDER_CONFIG_CONTAINER")"
ENV_IN="${CONF_DIR_IN}/${ENV_BASENAME}"
CONF_IN="${CONF_DIR_IN}/${CONF_BASENAME}"

# Session name & storage volume
RESUME_SESSION=0
if [ -z "$SESSION_NAME" ]; then
  if prompt_session_choice; then
    # Creating new session
    ensure_unique_container_name "$SESSION_NAME"
  else
    # Resuming existing session
    RESUME_SESSION=1
  fi
else
  # Session name provided via command line
  if docker ps -a --format '{{.Names}}' | grep -qx "$SESSION_NAME"; then
    echo "Session '$SESSION_NAME' already exists."
    read -r -p "Resume existing session? (y/N): " resume_choice
    case "$resume_choice" in
      [Yy]|[Yy][Ee][Ss])
        RESUME_SESSION=1
        ;;
      *)
        die "Session name '$SESSION_NAME' already exists. Choose a different --name or resume the existing one."
        ;;
    esac
  else
    ensure_unique_container_name "$SESSION_NAME"
  fi
fi

SESS_ROOT="${HOME}/.local/share/aider/sessions"
SESS_PATH="${SESS_ROOT}/${SESSION_NAME}"

if [ "$RESUME_SESSION" -eq 0 ]; then
  ensure_volume_bound "$SESSION_NAME" "$SESS_PATH"
fi

# Image pull policy
if [ "$PULL_IMAGE" -eq 1 ]; then
  docker pull "$IMAGE"
else
  docker image inspect "$IMAGE" >/dev/null 2>&1 || docker pull "$IMAGE"
fi

# ---------- inject default Aider flags if not present (use container paths) ----------
contains_flag() {
  local f="$1"; shift || true
  local x
  for x in "$@"; do
    if [ "$x" = "$f" ]; then return 0; fi
    case "$x" in "$f"=*) return 0 ;; esac
  done
  return 1
}

if ! contains_flag --env-file "${AIDER_ARGS[@]+"${AIDER_ARGS[@]}"}"; then
  AIDER_ARGS+=(--env-file "$ENV_IN")
fi
if ! contains_flag --config "${AIDER_ARGS[@]+"${AIDER_ARGS[@]}"}"; then
  AIDER_ARGS+=(--config "$CONF_IN")
fi

# ---------- run ----------
if [ "$RESUME_SESSION" -eq 1 ]; then
  echo "Resuming existing session: $SESSION_NAME"
  set -x
  docker start -ai "$SESSION_NAME"
  set +x
else
  DOCKER_VOLUMES=(
    --volume "$PWD:/app"
    --volume "$SESSION_NAME:/aider"
    --volume "$AIDER_ENV_FILE:$ENV_IN:ro"
    --volume "$AIDER_CONFIG_CONTAINER:$CONF_IN:ro"
  )

  # Mount Git config if it exists
  if [ -d "$GIT_CONFIG_DIR" ]; then
    DOCKER_VOLUMES+=(--volume "$GIT_CONFIG_DIR:$GIT_CONFIG_IN:ro")
  fi

  echo "Starting new session: $SESSION_NAME"
  set -x
  docker run \
    -it \
    --name "$SESSION_NAME" \
    --user "$(id -u):$(id -g)" \
    "${DOCKER_VOLUMES[@]}" \
    ${DOCKER_EXTRAS[@]+"${DOCKER_EXTRAS[@]}"} \
    "$IMAGE" \
    "${AIDER_ARGS[@]}"
  set +x
fi
