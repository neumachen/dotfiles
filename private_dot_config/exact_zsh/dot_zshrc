# vim:ft=zsh
# -*- mode: sh; sh-set-shell: zsh -*-

# Profiling Start
# zmodload zsh/zprof

source "${HOME}/.shtils"

# ZSH only and most performant way to check existence of an executable
# https://www.topbug.net/blog/2016/10/11/speed-test-check-the-existence-of-a-command-in-bash-and-zsh/
command_exists() { (( $+commands[$1] )); }

#############################
# zsh-snap Bootstrap
#############################

ZNAP_HOME="${ZNAP_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/zsh-snap}"
[[ -d "$ZNAP_HOME" ]] || mkdir -p "$ZNAP_HOME"

# Download zsh-snap if not present
if [[ ! -r "${ZNAP_HOME}/znap/znap.zsh" ]]; then
  echo-info "Downloading zsh-snap"
  git clone --depth 1 https://github.com/marlonrichert/zsh-snap.git "${ZNAP_HOME}/znap" \
    || echo-err "Unable to download zsh-snap"
fi

# Source zsh-snap
source "${ZNAP_HOME}/znap/znap.zsh"

#############################
# Local completions (before compinit)
#############################

# Add local completions directory to fpath
# This includes completions managed by chezmoi external:
# - _fzf, _eza, _kubectx, _kubens, _fd, _ghq, _git-forgit, _docker
# And local completions:
# - _rg, _just, _brownie, _kind
fpath=("${ZDOTDIR}/completions" $fpath)

#############################
# Environment Settings
#############################

# Smart URLs
autoload -Uz url-quote-magic
zle -N self-insert url-quote-magic

# General
setopt COMBINING_CHARS      # Combine zero-length punctuation characters
setopt INTERACTIVE_COMMENTS # Enable comments in interactive shell
setopt RC_QUOTES            # Allow 'Henry''s Whose' instead of 'Henry'\''s Whose'
unsetopt MAIL_WARNING       # Don't print warning if mail file accessed

# Jobs
setopt LONG_LIST_JOBS       # List jobs in long format
setopt AUTO_RESUME          # Attempt to resume existing job before creating new
setopt NOTIFY               # Report status of background jobs immediately
unsetopt BG_NICE            # Don't run background jobs at lower priority
unsetopt HUP                # Don't kill jobs on shell exit
unsetopt CHECK_JOBS         # Don't report on jobs when shell exit

#############################
# Input Settings
#############################

# Allow mapping Ctrl+S and Ctrl+Q shortcuts
[[ -r ${TTY:-} && -w ${TTY:-} && $+commands[stty] == 1 ]] && stty -ixon <$TTY >$TTY

# Use human-friendly identifiers for keybindings
zmodload -F zsh/terminfo +p:terminfo
typeset -gA key_info
key_info=(
  Control      '\C-'
  ControlLeft  '\e[1;5D \e[5D \e\e[D \eOd \eOD'
  ControlRight '\e[1;5C \e[5C \e\e[C \eOc \eOC'
  Escape       '\e'
  Meta         '\M-'
  Backspace    '^?'
  Delete       '^[[3~'
  BackTab      "${terminfo[kcbt]}"
  Left         "${terminfo[kcub1]}"
  Down         "${terminfo[kcud1]}"
  Right        "${terminfo[kcuf1]}"
  Up           "${terminfo[kcuu1]}"
  End          "${terminfo[kend]}"
  F1           "${terminfo[kf1]}"
  F2           "${terminfo[kf2]}"
  F3           "${terminfo[kf3]}"
  F4           "${terminfo[kf4]}"
  F5           "${terminfo[kf5]}"
  F6           "${terminfo[kf6]}"
  F7           "${terminfo[kf7]}"
  F8           "${terminfo[kf8]}"
  F9           "${terminfo[kf9]}"
  F10          "${terminfo[kf10]}"
  F11          "${terminfo[kf11]}"
  F12          "${terminfo[kf12]}"
  Home         "${terminfo[khome]}"
  Insert       "${terminfo[kich1]}"
  PageDown     "${terminfo[knp]}"
  PageUp       "${terminfo[kpp]}"
)

#############################
# Completion + menu behavior (MUST be before zsh-autocomplete)
#############################

# zsh-autocomplete: don't wait long to show menus; don't require lots of characters.
# (Raise min-input to 2â€“3 if it feels too eager.)
zstyle ':autocomplete:*' delay 0.05
zstyle ':autocomplete:*' min-input 1

# Make matching saner (case-insensitive).
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'

# fzf-tab quality-of-life (optional)
zstyle ':fzf-tab:*' switch-group ',' '.'

#############################
# Colors for completions (MUST be before fzf-tab)
#############################

# Load complist module for colored completions
zmodload zsh/complist

# Set LS_COLORS (used by fzf-tab for file coloring)
# If using eza/exa, you may already have EZA_COLORS; this covers ls-style colors
if command_exists vivid; then
  # If you have vivid installed, use it for a nice theme
  export LS_COLORS="$(vivid generate one-dark)"
elif command_exists dircolors; then
  # GNU dircolors
  eval "$(dircolors -b)"
elif [[ -f /usr/share/LS_COLORS/LS_COLORS ]]; then
  # Fallback to system LS_COLORS if available
  export LS_COLORS="$(cat /usr/share/LS_COLORS/LS_COLORS)"
else
  # Minimal fallback
  export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
fi

# Override other-writable (ow) and sticky+other-writable (tw) directory colors
# Use orange/yellow foreground (RGB 229,192,123 from one-dark theme) without background
# This makes them visually distinct from regular directories without the distracting green background
export LS_COLORS="${LS_COLORS}:ow=0;38;2;229;192;123:tw=0;38;2;229;192;123"

# EZA_COLORS: eza uses its own color variable; override ow/tw with orange/yellow
# This ensures eza (aliased as ls) shows other-writable dirs in a distinct color
export EZA_COLORS="${EZA_COLORS}:ow=38;2;229;192;123:tw=38;2;229;192;123"

# Tell zsh completion to use LS_COLORS
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"

# fzf-tab specific: enable ANSI color codes in preview
zstyle ':fzf-tab:*' fzf-flags --ansi

#############################
# Clipboard Functions (inlined from ohmyzsh)
#############################

# Copies data to clipboard from stdin
function clipcopy() {
  local file="${1:-/dev/stdin}"
  if [[ "$OSTYPE" == darwin* ]]; then
    cat "$file" | pbcopy
  elif [[ "$OSTYPE" == cygwin* || "$OSTYPE" == msys* ]]; then
    cat "$file" > /dev/clipboard
  elif command_exists xclip; then
    cat "$file" | xclip -selection clipboard
  elif command_exists xsel; then
    cat "$file" | xsel --clipboard --input
  elif command_exists wl-copy; then
    cat "$file" | wl-copy
  else
    echo "clipcopy: No clipboard program found" >&2
    return 1
  fi
}

# Pastes data from clipboard to stdout
function clippaste() {
  if [[ "$OSTYPE" == darwin* ]]; then
    pbpaste
  elif [[ "$OSTYPE" == cygwin* || "$OSTYPE" == msys* ]]; then
    cat /dev/clipboard
  elif command_exists xclip; then
    xclip -selection clipboard -out
  elif command_exists xsel; then
    xsel --clipboard --output
  elif command_exists wl-paste; then
    wl-paste
  else
    echo "clippaste: No clipboard program found" >&2
    return 1
  fi
}

#############################
# Plugins - Load Order Matters!
#############################

# Load mise first for tool detection
znap source joke/zim-mise

# Load zsh-vi-mode early to avoid rewriting fzf opts
znap source jeffreytse/zsh-vi-mode

# Syntax highlighting must load BEFORE zsh-autocomplete to avoid
# "unhandled ZLE widget" warnings for menu-search/recent-paths
znap source zdharma-continuum/fast-syntax-highlighting

# IMPORTANT:
# zsh-autocomplete must be loaded after syntax highlighting.
# It also expects you to NOT run compinit manually.
znap source marlonrichert/zsh-autocomplete

# Git utilities (plugin functionality, completions via chezmoi external)
znap source wfxr/forgit

# Chezmoi integration
znap source joke/zim-chezmoi

# GitHub CLI
znap source joke/zim-github-cli

# Kubernetes tools
znap source joke/zim-helm
znap source joke/zim-istioctl
znap source joke/zim-k9s
znap source joke/zim-kubectl
znap source joke/zim-minikube
znap source joke/zim-skaffold

# Alias finder
znap source shanwker1223/zim-alias-finder

# Starship prompt
znap source joke/zim-starship

#############################
# Eval commands (cached)
#############################

# broot
if [[ -f "${HOME}/.config/broot/launcher/bash/br" ]]; then
  source "${HOME}/.config/broot/launcher/bash/br"
fi

# zoxide
if command_exists zoxide; then
  znap eval zoxide 'zoxide init --cmd cd zsh'
fi

# starship
if command_exists starship; then
  znap eval starship 'starship init zsh'
fi

# cargo (via rustup)
if command_exists rustup; then
  znap fpath _rustup 'rustup completions zsh'
  znap fpath _cargo 'rustup completions zsh cargo'
fi

# chezmoi
if command_exists chezmoi; then
  znap fpath _chezmoi 'chezmoi completion zsh'
fi

# mole
if command_exists chezmoi; then
  znap fpath _mo 'mo completion zsh'
fi

# wezterm
if command_exists wezterm; then
  znap fpath _wezterm 'wezterm shell-completion --shell zsh'
fi

# aider
if command_exists aider; then
  znap fpath _aider 'aider --shell-completion zsh'
fi

#############################
# fzf-tab (load after zsh-autocomplete)
#############################

znap source Aloxaf/fzf-tab

# fzf-tab recommended: disable zsh's default menu for fzf-tab to take over
zstyle ':completion:*' menu no

# fzf-tab: preview for file/directory completions
# Use different preview for directories vs files
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza --color=always --icons -1 $realpath 2>/dev/null || ls --color=always $realpath 2>/dev/null'
zstyle ':fzf-tab:complete:ls:*' fzf-preview 'eza --color=always --icons -1 $realpath 2>/dev/null || ls --color=always $realpath 2>/dev/null'
zstyle ':fzf-tab:complete:*:*' fzf-preview 'if [[ -d $realpath ]]; then eza --color=always --icons -1 $realpath 2>/dev/null || ls --color=always $realpath 2>/dev/null; elif [[ -f $realpath ]]; then bat --color=always --style=numbers --line-range=:100 $realpath 2>/dev/null || head -100 $realpath 2>/dev/null; else echo $realpath; fi'

#############################
# FZF keybindings (must be in zvm_after_init to survive zsh-vi-mode)
#############################

function zvm_after_init() {
  local fzf_key_bindings_path="${HOME}/.local/share/fzf/shell/key-bindings.zsh"
  if [[ -f "$fzf_key_bindings_path" ]]; then
    source "$fzf_key_bindings_path"
  else
    echo-warn "fzf keybindings file: $fzf_key_bindings_path not found"
  fi
}

#############################
# Environment Variables (command-dependent, belongs in zshrc)
#############################

# Don't write python .pyc files, because they're not necessary and clutter
# directories with binary files
export PYTHONDONTWRITEBYTECODE=1

export FORGIT_STASH_FZF_OPTS="--bind='ctrl-d:reload(git stash drop $(cut -d: -f1 <<<{}) 1>/dev/null && git stash list)'"
export FORGIT_LOG_FZF_OPTS="--bind='ctrl-e:execute(echo {} |grep -Eo [a-f0-9]+ |head -1 |xargs git show |vim -)'"

export RIPGREP_CONFIG_PATH="${HOME}/.config/rg/.ripgreprc"

# Pager configuration - prefer ov over less
if command_exists ov; then
  export PAGER='ov'
  # ov with sensible defaults for man pages
  export MANPAGER='ov --section-delimiter "^[A-Z]" --section-header'
elif command_exists less; then
  export PAGER='less'
  export MANPAGER='less -is'
fi

# MANPAGER with nvim (overrides above if nvim is available)
if command_exists nvim; then
  export MANPAGER='nvim +Man!'
fi

# LESSOPEN - use lesspipe if available (still useful even with ov as some tools use less directly)
if command_exists lesspipe.sh; then
  export LESSOPEN="|lesspipe.sh %s"
elif [[ -x "/usr/local/bin/lesspipe.sh" ]]; then
  export LESSOPEN="|/usr/local/bin/lesspipe.sh %s"
elif [[ -x "/opt/homebrew/bin/lesspipe.sh" ]]; then
  export LESSOPEN="|/opt/homebrew/bin/lesspipe.sh %s"
fi

#############################
# Shell Options
#############################

# History
setopt APPEND_HISTORY         # Append to history file
setopt SHARE_HISTORY          # Share history between sessions
setopt HIST_REDUCE_BLANKS     # Remove superfluous blanks
setopt HIST_IGNORE_SPACE      # Don't record commands starting with space
setopt HIST_IGNORE_ALL_DUPS   # Remove older duplicate entries
setopt HIST_EXPIRE_DUPS_FIRST # Expire duplicates first when trimming
setopt HIST_VERIFY            # Show command before executing from history
setopt EXTENDED_HISTORY       # Record timestamp in history

# Directory
setopt AUTO_CD                # cd by typing directory name
setopt AUTO_PUSHD             # Push directories onto stack
setopt PUSHD_MINUS            # Exchange + and - in pushd
setopt PUSHD_SILENT           # Don't print directory stack
setopt PUSHD_TO_HOME          # pushd with no args goes home
setopt PUSHD_IGNORE_DUPS      # Don't push duplicates
setopt NO_HUP                 # Don't kill background jobs on exit

# Input/Output
setopt AUTO_MENU              # Show completion menu on tab
setopt CDABLE_VARS            # cd to named directories
setopt LIST_PACKED            # Compact completion lists
setopt LIST_TYPES             # Show file type indicators in completion
setopt HASH_LIST_ALL          # Hash command path on completion
setopt ALWAYS_TO_END          # Move cursor to end after completion
setopt NO_CORRECT             # Don't correct commands
setopt NO_CORRECT_ALL         # Don't correct arguments
setopt NO_BEEP                # No beep on error
setopt INTERACTIVE_COMMENTS   # Allow comments in interactive shell
setopt NOTIFY                 # Report job status immediately
setopt LONG_LIST_JOBS         # Long format for jobs
setopt MULTIOS                # Allow multiple redirections
# Note: completealiases is intentionally NOT set - it breaks alias completion

#############################
# Aliases
#############################

alias c='clear'

# Utility aliases
alias mkdir='mkdir -p'
alias df='df -kh'
alias du='du -kh'

# ls aliases
if command_exists eza; then
  alias ls='eza --group-directories-first'
  alias ll='eza -l --group-directories-first'
  alias la='eza -la --group-directories-first'
  alias lt='eza --tree --group-directories-first'
elif command_exists exa; then
  alias ls='exa --group-directories-first'
  alias ll='exa -l --group-directories-first'
  alias la='exa -la --group-directories-first'
  alias lt='exa --tree --group-directories-first'
else
  alias ll='ls -lh'
  alias la='ls -lAh'
fi

if [[ -n "$MEINE_HELFERLEIN" ]]; then
  pathmunge "$MEINE_HELFERLEIN" after
fi

if command_exists task; then
  taskwarrior_data_dir="${HOME}/.local/share/task"
  if [[ -d "${HOME}/Documents/taskwarrior" ]]; then
    taskwarrior_data_dir="${HOME}/Documents/taskwarrior"
    export TASKWARRIOR_DATA="${taskwarrior_data_dir}"
    export TASKRC="${HOME}/.config/taskwarrior/taskrc"

    if command_exists taskwarrior-tui; then
      alias taskui="taskwarrior-tui"
    fi
  fi
fi

if command_exists bat; then
  unalias -m 'cat'
  alias cat='bat -pp'
fi

if ! command_exists sudoedit; then
  alias sudoedit='sudo --edit'
fi

if command_exists shfmt; then
  alias my-shfmt="shfmt -i 2 -w -ci"
fi

if command_exists docker; then
  if docker compose >/dev/null 2>&1; then
    alias dcomp="docker compose"
  elif command_exists docker-compose; then
    alias dcomp="docker-compose"
  fi
fi

# Use Neovim as default vim/vi if available
if command_exists nvim; then
  alias vim='nvim'
  alias vi='nvim'
fi

if [[ -x "/opt/homebrew/opt/macos-trash/bin/trash" ]]; then
  alias rm='/opt/homebrew/opt/macos-trash/bin/trash'
fi

#############################
# History Configuration
#############################

HISTFILE="${HOME}/.local/share/zsh/history"
# Ensure the directory for HISTFILE exists
histfile_dir="$(dirname "${HISTFILE}")"
[[ ! -d "${histfile_dir}" ]] && mkdir -p "${histfile_dir}"

# Note: HISTIGNORE is a bash variable, not zsh. Use HISTORY_IGNORE for zsh:
HISTORY_IGNORE="(ls|ll|la|cd|cd -|pwd|exit|date|* --help)"
HISTSIZE=10000000
SAVEHIST=10000000

#############################
# Functions
#############################

function source-env() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: source-env <file> [file...]" >&2
    return 1
  fi

  for file in "$@"; do
    if [[ ! -f "${file}" ]]; then
      echo-err "the given file : ${file} does not exist"
      return 1
    fi

    source <(cat "${file}" | sed -n -e '/^#/d;/^\s*$/d' \
      -e "s/'/'\\\''/g" \
      -e "s/=\(.*\)/='\1'/g" \
      -e 's/.*/export &/p')
  done
}

function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [[ -n "$cwd" ]] && [[ "$cwd" != "$PWD" ]]; then
    builtin cd -- "$cwd"
  fi
  command rm -f -- "$tmp"
}

function reload-shell() {
  exec zsh -il
}

# Profiling End
# zprof
